---
title: "Raman Plots"
output:   
  html_notebook: 
    toc: true
    toc_float: true
author: Candace Savonen
date: 2020
---

## Set Up

This uses algorithms from `baselineWavelet`, so we need to install this if 
it hasn't been installed. 

```{r echo=FALSE}
if (!("tidyverse" %in% installed.packages())){
  install.packages("tidyverse")
}

if (!("baselineWavelet" %in% installed.packages())){
  devtools::install_github("zmzhang/baselineWavelet")
}

if (!("patchwork" %in% installed.packages())){
devtools::install_github("thomasp85/patchwork")
}

# magrittr pipe
`%>%` <- dplyr::`%>%`

library(Matrix)
library(patchwork)
```

### Directories and Files

The plots we make will be saved to this directory.

```{r}
# Path to output directory
plots_dir <- "plots"

# Create the plots_dir if it does not exist
if (!dir.exists(plots_dir)) {
  dir.create(plots_dir)
}

# Call the plot what you would like it to be saved as
plot_filename <- "raman_plot.png"
```

Any files that are in this directory will be run. 

```{r}
# Path to input directory
input_dir <- "MAD-X1"
```

```{r}
# Get the list of files from here
input_files <- list.files(input_dir, 
                          pattern="^.*\\.(csv|CSV)$", 
                          full.names = TRUE)
```

Collect experiment information from the file names.

```{r}
input_df <- data.frame(input_files) %>%
  # Split up file names into multiple columns so we can handle it easier
  tidyr::separate(input_files, sep = "_", into = c("file_path", "name", "pressure_pt", "pressure", "wavelength")) %>% 
  # Save input file paths as their own column too
  dplyr::mutate(input_files = input_files, 
                pressure = as.numeric(stringr::str_remove(pressure, " GPa"))) %>% 
  # Filter to only sets that have P (not dP)
  dplyr::filter(grepl("^P", pressure_pt)) %>%
  # Select only the columns we'll move forward with
  dplyr::select(input_files, pressure_pt, pressure, wavelength)

input_df
```

Neaten up the wavelength column. 

```{r}
input_df <- input_df %>%
  # Make the wavelength column only have the wavelength -- drop the dates
  dplyr::mutate(wavelength = as.numeric(stringr::word(wavelength, sep = " ", 2))) %>% 
  # Order the data.frame by the wavelength 
  dplyr::arrange(pressure, wavelength)

input_df
```

Where there's a 2800 and a 3200 for an individual pressure, only keep the 3200 file. 

```{r}
too_many <- input_df %>%
  dplyr::group_by(pressure)%>%
  dplyr::summarize(n = dplyr::n()) %>% 
  dplyr::filter(n > 3) %>% 
  dplyr::pull(pressure)

input_df <- input_df %>% 
  dplyr::filter(!(pressure == too_many & wavelength == 2800))
```

Print out the final version of the data frame with the input files. 

```{r}
input_df
```

## Specify the pressures and ranges for each file

Name the pressures for each file and make a table that explains the 
samples being plotted. 

**Double check the table printed out that it has the accurate pressure and range labels.**

```{r}
# Make a data.frame with each samples' information
sample_df <- input_df %>%
  dplyr::mutate(wave_min = dplyr::recode(wavelength, 
                          "375" = 200, 
                          "2275" = 1500, 
                          "2800" = 2800, 
                          "3200" = 2800
                        ),
                wave_max = dplyr::recode(wavelength, 
                          "375" = 1310, 
                          "2275" = 1875, 
                          "2800" = 3500, 
                          "3200" = 3500)
                ) 

# Print out the table so it can be double checked
knitr::kable(sample_df %>% dplyr::select(pressure, wavelength, wave_min, wave_max))
```

## Set up special functions

```{r}
read_n_correct <- function(filename, 
                           wavenum_min, 
                           wavenum_max) {
  # Will background correct and identify peaks for a given vibration dataset 
  # saved as a CSV file from
  #
  # Args:
  #   filename : A file path to to a vibration CSV file that has two columns
  #             The first column is wavenumber and the second is intensity.
  #   wavenum_min/max : two numbers which specify the range of numbers to keep in 
  #                    the dataset. Wavenumbers outside these ranges will be 
  #                    removed from the data.frame
  #
  # Returns:
  # A data.frame with background corrected intensities and peaks identified. 
  # Get file.path
  # 
  filename <- file.path(filename)
  
  # Check if the file actually exists
  if(!file.exists(filename)){
    stop(paste("No file at the given file path."))
  }
  
  # Read in the CSV data file colnames will be ignored
  vibration_df <- readr::read_csv(filename, col_names = FALSE) %>% 
    # Save the sensible column names
    dplyr::rename("wavenumber" = X1, 
                  "intensity" = X2) 
  # Establish the scale
  scales <- seq(1, 120, 1)
  
  # Find Continuous Wavelet Transform
  w_coefs <-  cwt(vibration_df$intensity,
                                   # The scales at which to perform CWT
                                   scales = scales, 
                                   # Which wavelet base to use
                                   wavelet = 'mexh')
  # Make this dat into an image
	print(
	  image(1:nrow(w_coefs), 
	        scales,
	        w_coefs, 
	        col = rainbow(256), 
	        axes = FALSE, 
	        xlab = 'index', 
	        ylab = 'CWT coefficient scale', 
	        main = 'CWT coefficients')
	)

	# Identify the local maximum of each column in 2-D CWT coefficients matrix
	# by using a slide window
	local_max <- getLocalMaximumCWT(w_coefs, 
	                                # Minimum window 
	                                minWinSize = 0.5)
  # Identify ridges by connecting the local maximum of 2-D 
	ridge_list <- getRidge(local_max,
	                       gapTh = 3, 
	                       skip = NULL)
	
	# Identify the major peaks
	major_peak_info <- identifyMajorPeaks(vibration_df$intensity,
	                                                       ridge_list,
	                                                       w_coefs,
	                                                       SNR.Th = 0.2,
	                                                       ridgeLength = 1,
	                                                       nearbyPeak = TRUE)
	# Estimate peak width
	peak_width <- widthEstimationCWT(vibration_df$intensity,
	                                                  major_peak_info)
	# Plot the ridge list
	plotRidgeList(ridge_list)
	
	# Make the data.frame with the corrected data columns. 
	vibration_df <- vibration_df %>% 
	  dplyr::mutate(
	    # Make background a new column based on intensity column
	    background = baselineCorrectionCWT(
	      intensity,
	      peak_width,
	      lambda = 1000,
	      differences = 1),
	    # Save corrected intensity as a new column 
	    corrected_intensity = intensity - background, 
	    # Save binned column
	    binned = lowess(wavenumber, 
	                    corrected_intensity, 
	                    f = 0.03)$x, 
	    # Save uncorrected bin column
	    uncorrected_bin = lowess(wavenumber, 
	                             intensity, 
	                             f = 0.03)$x, 
	    # Save new column that says which are major peaks
	    major_peak = (1:nrow(.) %in% major_peak_info$peakIndex), 
	    wavenumber = as.numeric(wavenumber)
	    ) %>% 
	  dplyr::filter(wavenumber > wavenum_min, 
	                wavenumber < wavenum_max) 
	
	# Return the data.frame with the corrected columns
	return(vibration_df)
}
```

Function for plotting the individual peaks

```{r}
plot_ind_peaks <- function(vibration_df) {
  # Given a vibration data.frame that has been corrected already using 
  # `read_n_correct` function, make an individual peak shape for ultimate plot
  #
  # Args:
  #   vibration_df : A corrected vibration dataset as a data.frame with 
  #                  `corrected_intensity`, `wavenumber` and `major_peak` as 
  #                  columns. 
  #   x_lab: x axis label 
  #   y_lab: y axis label
  #
  # Returns:
  # A data.frame with background corrected intensities. 
  
  # Make a plot with no axises or other stuff, but has the peaks
	ggplot2::ggplot(vibration_df) + 
	  ggplot2::geom_line(ggplot2::aes(x = wavenumber, 
	                                  y = corrected_intensity)) +
	  ggplot2::geom_point(data = subset(vibration_df, major_peak), 
	                      ggplot2::aes(x = wavenumber, 
	                                   y = corrected_intensity, 
	                                   shape = major_peak)) +
	  ggplot2::theme_classic() + 
    ggplot2::xlim(c(round(min(vibration_df$wavenumber)), 
                    round(max(vibration_df$wavenumber)))) +
    ggplot2::xlab("") + 
    ggplot2::ylab("") +
    # Make everything blank because we just want the peak shape
    ggplot2::theme(legend.position = "none", 
                   axis.line = ggplot2::element_blank()) 
}
```

Make quick little functions that remove axis ticks and labels. 

```{r}
remove_x_axis <- function(gplot) {
  gplot <- gplot + ggplot2::theme(
  axis.title.x = ggplot2::element_blank(),
  axis.text.x = ggplot2::element_blank(),
  axis.ticks.x = ggplot2::element_blank())
  
  return(gplot)
}
```

Same kind of function but for y axis. 

```{r}
remove_y_axis <- function(gplot) {
  gplot <- gplot + ggplot2::theme(
  axis.title.y = ggplot2::element_blank(),
  axis.text.y = ggplot2::element_blank(),
  axis.ticks.y = ggplot2::element_blank())
  
  return(gplot)
}
```

Wrapper function that does both. 

```{r}
remove_axes <- function(gplot) {
  gplot <- gplot + ggplot2::theme(
  axis.title.y = ggplot2::element_blank(),
  axis.text.y = ggplot2::element_blank(),
  axis.ticks.y = ggplot2::element_blank(), 
  axis.title.x = ggplot2::element_blank(),
  axis.text.x = ggplot2::element_blank(),
  axis.ticks.x = ggplot2::element_blank())
  
  return(gplot)
}
```

## Run each data file through the correction algorithms

Use the specialized function to import and correct the data from each file.

```{r}
# Read, background correct, and identify peaks of each sample
corrected_datasets <- apply(sample_df, 1, 
                            function(file) {
                            read_n_correct(filename = file['input_files'], 
                                           wavenum_min = file['wave_min'],
                                           wavenum_max = file['wave_max'])
                              })

# Bring along the sample labels
names(corrected_datasets) <- paste0(sample_df$pressure, 
                            "GPa",
                            sample_df$wave_min,
                            "-", 
                            sample_df$wave_max,
                            each = "")
```

## Obtain a individual plot for each corrected dataset

```{r}
peak_plots <- lapply(corrected_datasets, 
                     plot_ind_peaks)

names(peak_plots) <- paste0(sample_df$pressure, 
                            "GPa",
                            sample_df$wave_min,
                            "-", 
                            sample_df$wave_max,
                            each = "")
```

## Assemble the main plot

Put together all the peak plots into one grid. 
Assemble by row. 

```{r}
n_rows <- 2
```

Assemble first row. 

```{r}
first_row <- 
  remove_x_axis(peak_plots$`2.914GPa200-1310`)  +
  remove_axes(peak_plots$`2.914GPa1500-1875`) + 
  remove_axes(peak_plots$`2.914GPa2800-3500`)
```

Assemble second row. 

```{r}
second_row <- 
  peak_plots$`5.48GPa200-1310` +  
  remove_y_axis(peak_plots$`5.48GPa1500-1875`) +
  remove_y_axis(peak_plots$`5.48GPa2800-3500`)
```

### Combine rows

```{r}
ultimate_plot <- first_row / second_row 
```

## Add annotation labels

Declare x and y labels and main title. 

```{r}
# Declare the main title
main_title <- "The background-correction of Raman Spectra"

# Declare x label
x_lab <- "Wavelength / nm"

# Declare y label
y_lab <- "Raman Intensity/Arbitr. Units"
```

Set up the formatting of our x and y labels. 

```{r}
x_lab <- wrap_elements(grid::textGrob(x_lab)) + 
  ggplot2::theme(
    plot.margin = ggplot2::unit(c(.001, .001, .001, .001), "cm")
    )

y_lab <- wrap_elements(grid::textGrob(y_lab, rot = 90)) + 
  ggplot2::theme(
    plot.margin = ggplot2::unit(c(.01, .01, .01, .01), "cm")
    )
```

Tack on the axis labels first.

```{r}
ultimate_plot <- 
  # Start with y label
  (y_lab + ultimate_plot) +
   plot_layout(
    widths = c(0.15, 5) # Adjust spacing 
    ) 

ultimate_plot <- 
  (ultimate_plot / x_lab) + 
  # Adjust spacing 
  plot_layout(
    heights = c(5, 0.5) # Adjust spacing 
    )
```

Add title. 

```{r}
ultimate_plot <- ultimate_plot + 
  plot_annotation(
  title = ggplot2::element_text(main_title),
  )
```

Print out preview of the final plot. 

```{r}
ultimate_plot

corrected_datasets$`2.914GPa200-1310`
```

Save plot to a png

```{r}
ggplot2::ggsave(
  filename = file.path(plots_dir, plot_filename), 
  plot = ultimate_plot, 
  width = 10)
```

## Session Info

```{r}
sessionInfo()
```

